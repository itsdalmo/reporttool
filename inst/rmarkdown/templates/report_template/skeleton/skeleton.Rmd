---
title: "Kundetilfredshet"
subtitle: "REPLACE_ENTITY"
author: "EPSI Norge"
date: "REPLACE_DATE"
output: 
  reporttool::beamer_template
---

```{r, error=FALSE, results='hide'}

# Replace entity and path to data ----------------------------------------------

input <- "REPLACE_DATA"
entity <- "REPLACE_ENTITY"

# Package dependencies ---------------------------------------------------------

# Reading and manipulating data
suppressMessages(library(reporttool))
suppressMessages(library(dplyr))
suppressMessages(library(tidyr))

# Plotting
suppressMessages(library(ggplot2))
suppressMessages(library(grid))
suppressMessages(library(scales))

# Latex tables and string formatting
suppressMessages(library(xtable))
suppressMessages(library(stringi))

# Default values ---------------------------------------------------------------

latents <- get_default("latents")
palette <- get_default("palette")
cutoff <- as.numeric(cfg$value[cfg$config %in% "cutoff"])

# Workbook (create and add open answers etc if needed) -------------------------
wb <- openxlsx::createWorkbook()

# Load the data if necessary ---------------------------------------------------
# (Could already be loaded by reporttool::generate_report)

if (!all(exists("df"), exists("mm"), exists("ents"))) {
  data <- get_survey(input)
  for(i in names(data)) { assign(i, data[[i]]) }
}

# Remove common suffixes in entity names (e.g, "AS")
if (!is.na(tr$replacement[tr$original == "entity_short"])) {
  entity_short <- stri_replace(entity, "", regex = stri_c(" ?", tr$replacement[tr$original == "entity_short"], "[^ ]+ ?"))
} else {
  entity_short <- entity
}

# Get names for averages and chunk eval options --------------------------------
ent_sum <- tr$replacement[tr$original == "average"]
ctr_sum <- tr$replacement[tr$original == "contrast_average"]
stu_sum <- tr$replacement[tr$original == "study_average"]


# See if the entity has any historical data and/or contrast data exists (True/False):
historical <- if (exists("hd")) entity %in% hd$mainentity else FALSE
contrast <- if (exists("cd")) nrow(cd) > 0 else FALSE
subentities <- "subentity" %in% names(df)

# Check if any statements should be plotted (metric or categorical) ------------
statement_metric <- "statement_metric" %in% stri_trans_tolower(mm$latent)
statement_categorical <- "statement_categorical" %in% stri_trans_tolower(mm$latent)

# Check variables for open answers in complaints -------------------------------
complaint <- any(c("open_complaint", "open_wouldcomplain") %in% stri_trans_tolower(mm$latent))
open_noncomplaint <- "open_noncomplaint" %in% stri_trans_tolower(mm$latent)
open_wouldcomplain <- "open_wouldcomplain" %in% stri_trans_tolower(mm$latent)
oa_positive <- "oa_positive" %in% stri_trans_tolower(mm$latent)
oa_negative <- "oa_negative" %in% stri_trans_tolower(mm$latent)
open_answer <- "open_answer" %in% stri_trans_tolower(mm$latent)
```

```{r, error=FALSE, results='hide'}
# Collect information on the survey --------------------------------------------
info <- list()

# Dates
if (any(mm$type == "date")) {
  dvar <- filter(mm, type == "date") %>% select(manifest)
  dvar <- dvar$manifest[1] # In case there is more than 1 variable
  
  # Get min and max date, month and year
  info$start <- format(min(df[[dvar]], na.rm = TRUE), "%e. %b. %Y")
  info$end <- format(max(df[[dvar]], na.rm = TRUE), "%e. %b. %Y")
  info$month <- format(min(df[[dvar]], na.rm = TRUE), "%e. %b. %Y")
  info$year <- format(min(df[[dvar]], na.rm = TRUE), "%Y")
  
  # Infer period from month and add translation
  info$period <- ifelse(info$month <= 6, 
                        tr$replacement[tr$original == "spring"], 
                        tr$replacement[tr$original == "fall"])
  info$period <- stri_c(info$period, info$year)
}


# Response information ---------------------------------------------------------
info$respondents <- ents$n[ents$entity %in% entity]
info$valid <- ents$valid[ents$entity %in% entity]
info$valid_percent <- info$valid/info$respondents

# Number of latents and model questions ----------------------------------------    
info$questions <- nrow(mm[stri_trans_tolower(mm$latent) %in% latents, ])

# Response per subentity (if specified) ----------------------------------------
if (!"percent_missing" %in% names(df) && "andel_missing" %in% names(df)) {
  df$percent_missing <- df$andel_missing
}

if (subentities) {
  valid_sub <- df %>%
    filter(mainentity == entity & percent_missing <= cutoff) %>%
    group_by(subentity) %>%
    summarise(valid = n()) %>%
    mutate(valid = stri_c(subentity, valid, sep = " "))
}

# Remove incomplete observations -----------------------------------------------
df <- df %>% filter(percent_missing <= cutoff)

```

# Forord
## Gjennomføring

- Målgruppen for denne undersøkelsen er kunder av `r entity`.
- Svarene er avgitt på web i perioden `r info$start` til `r info$end`, og er gjort via Research.net[^1].
- Respondentene (de som er invitert til å delta) kan potensielt motta 3 e-poster - hvorav den første er en standard utsendelse, samt 2 påminnelser til de som ikke svarte på den første utsendelsen og evt. den første påminnelsen.
- Totalt antall besvarelser for undersøkelsen var `r info$respondents`, og av disse kunne `r stri_c(info$valid_percent, "%")` benyttes i analysene.
`r if (subentities) stri_c("- ", "Svarprosent per ", stri_trans_tolower(tr$replacement[tr$original == "subentity"]), ": ", stri_c(valid_sub$res, collapse = ", "))`
- Det er hentet inn svar på `r info$questions` spørsmål som bygger opp under hovedanalysen, samt enkelte bakgrunnsspørsmål som bidrar med ytterligere innsikt i forhold til kundeopplevelsen. 
- Alle resultatene som presenteres i denne rapporten er overlevert for bruk ved `r entity`.
- Resultatene fra denne undersøkelsen vil ikke publiseres i det offentlige rom av EPSI. Dere står selv fritt til å dele resultatene med andre.
- Se EPSIS hjemmesider[^2] for våre publiserte undersøkelser.

[^1]: [http://surveymonkey.com](http://surveymonkey.com)
[^2]: [http://epsi-norway.org](http://epsi-norway.org)


## Skala og svar


- Indeksen for kundetilfredshet presenteres som en verdi mellom 0 og 100, og er det sentrale målet i disse målingene. Dette er en indeksverdi, ikke en prosentverdi. Jo høyere verdi desto bedre anser kundene at leverandøren oppfyller deres krav og forventninger. 
- Spørsmålene svares på en skala fra 1 til 10, hvor 1 betyr "helt uenig" eller "veldig misfornøyd" og hvor 10 betyr "helt enig" eller "veldig fornøyd".
- Resultatene gjøres i etterkant om til en 100-punkts skala.

- Som en generell regel kan man si at:
    - Målinger under 60 er lavt/veldig lavt (vanskeligheter med å motivere kundene til å bli).
    - Målinger fra 60 - 75 er gjennomsnittlig  
    - Målinger over 75 anses som høyt/veldig høyt (peker på en sterk relasjon mellom kundene og leverandøren).  

- Som en tommelfingerregel så er forskjeller på mer enn 3 poeng signifikante. Dette innebærer at man med en viss grad av sikkerhet kan si at forskjellen mellom to indeksverdier er for stor til å være tilfeldig. 
- Se www.epsi-norway.org for mer informasjon om metode og modell, eller om EPSI for øvrig.

## Aspekter i EPSI modellen

- **`r tr$replacement[stri_trans_tolower(tr$original) == "image"]`** (`r mm$manifest[stri_trans_tolower(mm$latent) %in% "image"]`)  er målt for å gi en forståelse av respondentenes opplevelse av omdømmet til `r entity`.

- **`r tr$replacement[stri_trans_tolower(tr$original) == "expect"]`** (`r mm$manifest[stri_trans_tolower(mm$latent) %in% "expect"]`) er et mål på hva respondentene forventer å få ut av kundeforholdet.

- **`r tr$replacement[stri_trans_tolower(tr$original) == "prodq"]`** (`r mm$manifest[stri_trans_tolower(mm$latent) %in% "prodq"]`) fanger respondentens opplevelse av tjeneste- og produkttilbudet.

- **`r tr$replacement[stri_trans_tolower(tr$original) == "servq"]`** (`r mm$manifest[stri_trans_tolower(mm$latent) %in% "servq"]`) har fokus på forholdet mellom respondentene og de ansatte hos leverandøren når det gjelder opplevelsen av service og det mer mellommenneskelige.

- **`r tr$replacement[stri_trans_tolower(tr$original) == "value"]`** (`r mm$manifest[stri_trans_tolower(mm$latent) %in% "value"]`) er utformet for å fange opp forholdet mellom hva som er oppnådd (levert) og prisen / kostnaden for å få dette, sett fra respondentenes ståsted. 

- **`r tr$replacement[stri_trans_tolower(tr$original) == "epsi"]`** (KTI) er det sentrale målet i modellen, og reflekterer hvorvidt kundene opplever at deres krav og forventninger blir oppfylt. Resultatet for selskapet beregnes på bakgrunn av `r length(mm$manifest[stri_trans_tolower(mm$latent) %in% "epsi"])` spørsmål (`r mm$manifest[stri_trans_tolower(mm$latent) %in% "epsi"]`).

- **`r tr$replacement[stri_trans_tolower(tr$original) == "loyal"]`** (`r mm$manifest[stri_trans_tolower(mm$latent) %in% "loyal"]`) måler eksempelvis hvorvidt respondenten ville valgt samme leverandør dersom vedkommende måtte velge på nytt. Forskning viser at lojalitet i stor grad er påvirket av kundetilfredsheten.

- Generelt så er det viktig med en balanse mellom forventninger og opplevd kvalitet (selve leveransen). Med andre ord, dersom gapet mellom hva kundene forventer og hvordan de opplever kvaliteten (negativt gap) blir for stor så vil det ha negativ betydning på tilfredsheten med selskapet.

- **NB**: I spørsmålsteksten er {XX} benyttet som en plassholder. Da respondentene svarte på undersøkelsen ble dette feltet byttet ut med navnet på selskapet (altså `r entity`).


# Kundeprofil for `r entity`

```{r}
# Frametitle -------------------------------------------------------------------
cat("##", "","\n", sep=" ")

# Add the contrast (average of the current or previous study) ------------------
if (contrast) {
  pd <- df %>% filter(mainentity == entity) %>% bind_rows(., mutate(cd, mainentity = ctr_sum))
} else {
  pd <- df %>% filter(mainentity == entity) %>% bind_rows(., mutate(df, mainentity = stu_sum))
}

# Gather the data for the table ------------------------------------------------
pd <- pd %>%
      select(mainentity, one_of(latents), w) %>%
      mutate_each(funs(n = as.numeric(.)), -mainentity) %>%
      group_by(mainentity) %>%
      summarise_each(funs(wm = weighted.mean(., w=w, na.rm = TRUE)), -w)

# Convert to proper format for plotting ----------------------------------------
pd <- pd %>% 
      gather(latent, score, -mainentity) %>%
      mutate(latent = as.character(latent)) %>%
      left_join(cf, by = c("latent" = "original")) %>%
      mutate(latent = factor(replacement, levels=unique(replacement)), ordered = TRUE) %>%
      mutate(mainentity = factor(mainentity, levels = c(entity, if (contrast) ctr_sum else stu_sum), ordered = TRUE)) %>%
      select(mainentity, latent, score)

# Get the vertical justification for geom text ---------------------------------
vjust <- pd %>% spread(mainentity, score)
vjust$overlap <- if (ncol(vjust) > 3) rowMeans(vjust[, 2:ncol(vjust)]) else vjust[[ncol(vjust)]]
vjust <- ifelse(vjust[[entity]] < vjust[["overlap"]], "2", "-1")

# Calculate appropriate range for y-axis ---------------------------------------
y_max <- ifelse(max(pd[["score"]]) < 90, round(max(pd[["score"]])+10, -1), 100)
y_min <- ifelse(min(pd[["score"]]) > 10, round(min(pd["score"])-10, -1), 0)

# Create the profile-plot ------------------------------------------------------
p <- ggplot(data=pd, aes(x=latent, y=score, group=mainentity, colour=mainentity))
p + geom_line(size=1) +
    geom_point(size=3) +
    scale_color_manual(values = setNames(palette, unique(pd$mainentity))) +
    geom_text(data = filter(pd, mainentity == entity), 
              aes(label=format(round(score, 1))),  
              size=4, colour="#23373b", vjust=vjust) + 
    ylim(y_min, y_max) + 
    plot_theme()
```

`r if(subentities == T) stri_c("# Profil per", stri_trans_tolower(tr$replacement[tr$original == "subentity" & !is.na(tr$original)]), sep = " ")`

```{r, eval=subentities}
# Frametitle -------------------------------------------------------------------
cat("##", "","\n", sep=" ")

# Gather the data for the table ------------------------------------------------
pd <- pd %>%
      select(mainentity, subentity, one_of(latents)) %>%
      filter(mainentity == entity) %>%
      mutate_each(funs(n = as.numeric(.)), -mainentity, -subentity) %>%
      bind_rows(mutate(., mainentity = stri_c(ent_sum, entity_short, sep = " ")), mutate(., mainentity = subentity)) %>%
      group_by(mainentity) %>%
      summarise_each(funs(m = mean(., na.rm = TRUE)))

# Convert to proper format for plotting ----------------------------------------
pd <- pd %>% 
      gather(latent, score, -mainentity, -subentity) %>%
      mutate(latent = as.character(latent)) %>%
      left_join(cf, by = c("latent" = "original")) %>%
      mutate(latent = factor(replacement, levels=unique(replacement)), ordered = TRUE) %>%
      mutate(mainentity = factor(mainentity, levels = c(stri_c(ent_sum, entity_short, sep = " ")), unique(subentity), ordered = TRUE)) %>%
      select(mainentity, latent, score)

# Get the vertical justification for geom text ---------------------------------
vjust <- pd %>% spread(mainentity, score)
vjust$overlap <- if (ncol(vjust) > 3) rowMeans(vjust[, 2:ncol(vjust)]) else vjust[[ncol(vjust)]]
vjust <- ifelse(vjust[[entity]] < vjust[["overlap"]], "2", "-1")

# Calculate appropriate range for y-axis ---------------------------------------
y_max <- ifelse(max(pd[["score"]]) < 90, round(max(pd[["score"]])+10, -1), 100)
y_min <- ifelse(min(pd[["score"]]) > 10, round(min(pd["score"])-10, -1), 0)

# Make the average a dashed line -----------------------------------------------
pd$lines <- ifelse(pd$mainentity == stri_c(ent_sum, entity_short, sep = " "), "solid", "dashed")

# Create the profile-plot ------------------------------------------------------
p <- ggplot(data=pd, aes(x=latent, y=score, group=mainentity, colour=mainentity, linetype=lines))
p + geom_line(size=1) +
    geom_point(size=3) +
    scale_color_manual(values = setNames(palette, unique(pd$mainentity))) +
    geom_text(data = filter(pd, mainentity == stri_c(ent_sum, entity_short, sep = " ")), 
              aes(label=format(round(score, 1))),  
              size=4, colour="#23373b", vjust=vjust) + 
    ylim(y_min, y_max) + 
    guides(linetype=FALSE) +
    plot_theme()
```

`r if(historical == T) stri_c("# Historisk profil for", entity, sep = " ")`

```{r, eval=historical}
# Frametitle -------------------------------------------------------------------
cat("##", "","\n", sep=" ")

# Gather the data for plotting -------------------------------------------------
pd <- hd %>%
      select(semester, year, mainentity, subentity, one_of(latents)) %>%
      filter(mainentity == entity, subentity == ent_sum) %>%
      arrange(desc(year), semester) %>%
      mutate(semester = ifelse(stri_trans_tolower(semester) == "spring", 
                               tr$replacement[tr$original == "spring"], semester)) %>%
      mutate(semester = ifelse(stri_trans_tolower(semester) == "fall", 
                               tr$replacement[tr$original == "fall"], semester)) %>%
      mutate(mainentity = stri_c(semester, year, sep = " ")) %>%
      select(-semester, -year, -subentity) %>%
      mutate_each(funs(num = as.numeric(.)), -mainentity)
  

pd <- df %>%
      select(mainentity, one_of(latents)) %>%
      filter(mainentity == entity) %>%
      group_by(mainentity) %>% 
      summarise_each(funs(m = mean(as.numeric(.), na.rm=T))) %>%
      mutate("mainentity" = survey$period[1]) %>%
      bind_rows(., pd)

# Convert to proper format for plotting ----------------------------------------
pd <- pd %>%
      gather(latent, score, -mainentity) %>%
      mutate(latent = as.character(latent)) %>%
      left_join(cf, by = c("latent" = "original")) %>%
      mutate(latent = factor(replacement, levels=unique(replacement))) %>%
      mutate(mainentity = factor(mainentity, levels=unique(mainentity))) %>%
      select(mainentity, latent, score)

# Get the vertical justification for geom text ---------------------------------
vjust <- pd %>% spread(mainentity, score)
vjust$overlap <- if (ncol(vjust) > 3) rowMeans(vjust[, 2:ncol(vjust)]) else vjust[[ncol(vjust)]]
vjust <- ifelse(vjust[[entity]] < vjust[["overlap"]], "2", "-1")

# Calculate appropriate range for y-axis ---------------------------------------
y_max <- ifelse(max(pd[["score"]]) < 90, round(max(pd[["score"]])+10, -1), 100)
y_min <- ifelse(min(pd[["score"]]) > 10, round(min(pd["score"])-10, -1), 0)

# Create the profile-plot ------------------------------------------------------
p <- ggplot(data=pd, aes(x=latent, y=score, group=mainentity, colour=mainentity))
p + geom_line(size=1) +
    scale_color_manual(values = setNames(palette, levels(pd$mainentity))) +
    geom_point(size=3) +
    geom_text(data = filter(pd, mainentity == survey$period[1]), 
              aes(label=format(round(score, 1))),  
              size=4, colour="#23373b", vjust=vjust) + 
    ylim(y_min, y_max) + 
    plot_theme()
```

# SWOT

```{r}
# Frametitle -------------------------------------------------------------------
if (contrast) {
  cat("##", "Differansen mellom", entity, "og", stri_trans_tolower(ctr_sum) ,"\n", sep=" ")
} else {
  cat("##", "Differansen mellom", entity, "og", stri_trans_tolower(stu_sum) ,"\n", sep=" ")
}

# Get list of manifest names in correct order ----------------------------------
manifests <- data.frame("latent" = latents, stringsAsFactors = FALSE) %>%
             left_join(mutate(mm, latent = stri_trans_tolower(latent)), by = c("latent" = "latent")) %>%
             mutate(question = ifelse(stri_length(question) >= 90, stri_c(strtrim(question, width=90-3), "..."), question))


# Add the contrast (average of the current or previous study) ------------------
if (contrast) {
  pd <- df %>% filter(mainentity == entity) %>% bind_rows(., mutate(cd, mainentity = ctr_sum))
} else {
  pd <- df %>% filter(mainentity == entity) %>% bind_rows(., mutate(df, mainentity = stu_sum))
}

# Gather the data for the table ------------------------------------------------
pd <- pd %>%
      select(mainentity, one_of(stri_c(stri_trans_tolower(manifests$manifest), "em")), w) %>%
      group_by(mainentity) %>%
      summarise_each(funs(wm = weighted.mean(as.numeric(.), w=w, na.rm=T)), -w)

# Convert to a longer format and convert to proper variable names --------------
pd <- pd %>%
      gather(manifest, score, -mainentity) %>% 
      mutate(manifest = stri_replace(manifest, "", regex = "[eE][mM]$")) %>%
      left_join(manifests, by = c("manifest" = "manifest")) %>%
      mutate(manifest = stri_replace(manifest, "Q", regex = "^q")) %>%
      mutate(manifest = factor(manifest, levels=unique(manifest))) %>%
      mutate(mainentity = factor(mainentity, levels = c(entity, if (contrast) ctr_sum else stu_sum), ordered = TRUE)) %>%
      spread(mainentity, score, fill=0)

# Calculate the difference between the entity and the average ------------------
if (stu_sum %in% names(pd)) {
    pd$difference <- pd[[entity]] - pd[[stu_sum]]
    pd$difference[pd[[stu_sum]] == 0] <- NA
} 

if (ctr_sum %in% names(pd)) {
  pd$difference <- pd[[entity]] - pd[[ctr_sum]]
  pd$difference[pd[[ctr_sum]] == 0] <- NA
}

# Ready the data for plotting --------------------------------------------------
pd <- pd %>%
      select(manifest, question, difference) %>%
      mutate("sign" = ifelse(difference > 0, 1, 0)) %>%
      mutate(sign = factor(sign, levels=unique(sign))) %>%
      mutate(question = stri_c(manifest, question, sep = " - ")) %>%
      mutate(question = factor(question, levels=rev(unique(question))))

# Calculate appropriate range for y-axis ---------------------------------------
y_min <- 5*floor(min(pd$difference, na.rm=TRUE)/4)
y_max <- 5*ceiling(max(pd$difference, na.rm=TRUE)/4)

# Create the plot --------------------------------------------------------------
p <- ggplot(data=pd, aes(x=question, y=difference, fill=sign))
p + geom_bar(stat="identity", width=0.5, position="dodge") + 
    coord_flip(ylim = c(y_min, y_max)) +
    scale_fill_manual(values=setNames(palette, c(0,1))) +
    geom_hline(xintercept=0, size=.5, colour = "#D0D0D0") +
    geom_text(data = filter(pd, sign == 1), 
              aes(label=format(round(difference, 1))),  
              size=3, colour="#23373b", vjust=.2, hjust=-.55) +
    geom_text(data = filter(pd, sign == 0), 
              aes(label=format(round(difference, 1))),  
              size=3, colour="#23373b", vjust=.3, hjust=+1.5) +
    plot_theme(legend="none") + 
    theme(plot.margin = unit(c(1, 1.5, 0.5, 0.5), "lines"),
          axis.text.x = element_text(angle = 45, hjust = 1),
          panel.grid = element_blank())
```


# Resultat per spørsmål

```{r}
# Frametitle -------------------------------------------------------------------
if (contrast) {
  cat("##", "Differansen mellom", entity, "og", stri_trans_tolower(ctr_sum) ,"\n", sep=" ")
} else {
  cat("##", "Differansen mellom", entity, "og", stri_trans_tolower(stu_sum) ,"\n", sep=" ")
}

# Get list of manifest names in correct order ----------------------------------
manifests <- data.frame("latent" = latents, stringsAsFactors = FALSE) %>%
             left_join(mutate(mm, latent = stri_trans_tolower(latent)), by = c("latent" = "latent"))


# Add the contrast (average of the current or previous study) ------------------
if (contrast) {
  pd <- df %>% filter(mainentity == entity) %>% bind_rows(., mutate(cd, mainentity = ctr_sum))
} else {
  pd <- df %>% filter(mainentity == entity) %>% bind_rows(., mutate(df, mainentity = stu_sum))
}

# Gather the data for the table ------------------------------------------------
pd <- pd %>%
      select(mainentity, one_of(stri_c(stri_trans_tolower(manifests$manifest), "em")), w) %>%
      group_by(mainentity) %>%
      summarise_each(funs(wm = weighted.mean(as.numeric(.), w=w, na.rm=T)), -w)

# Convert to a longer format and convert to proper variable names --------------
pd <- pd %>%
      gather(manifest, score, -mainentity) %>% 
      mutate(manifest = stri_replace(manifest, "", regex = "[eE][mM]$")) %>%
      left_join(manifests, by = c("manifest" = "manifest")) %>%
      mutate(manifest = stri_replace(manifest, "Q", regex = "^q")) %>%
      mutate(manifest = factor(manifest, levels=unique(manifest))) %>%
      mutate(mainentity = factor(mainentity, levels = c(entity, if (contrast) ctr_sum else stu_sum), ordered = TRUE)) %>%
      select(latent, manifest, question, mainentity, score) %>%
      spread(mainentity, score, fill=0) %>%
      mutate(latent = factor(latent, levels = latents, ordered = TRUE)) %>%
      arrange(latent)

# Calculate the difference between the entity and the average ------------------
if (stu_sum %in% names(pd)) {
    pd$difference <- pd[[entity]] - pd[[stu_sum]]
    pd$difference[pd[[stu_sum]] == 0] <- NA
} 

if (ctr_sum %in% names(pd)) {
  pd$difference <- pd[[entity]] - pd[[ctr_sum]]
  pd$difference[pd[[ctr_sum]] == 0] <- NA
}

# Replace headers with the translation from config -----------------------------
names(pd) <- ordered_replace(names(pd), setNames(tr$original, tr$replacement))

# Fix encoding issues on windows -----------------------------------------------
if (Sys.info()[1] == "Windows") {
  names(pd) <- vapply(names(pd), function(x) {
    ifelse(Encoding(x) != "unknown", iconv(x, "UTF-8", "latin1"), x)}, character(1))
}

# Get length of column headers for the table, and truncate manifest text if needed:
max_length <- 110 - 2*length(names(pd)) - sum(stri_length(names(pd)[-2]))
max_length <- floor(max_length/5)*5

min_length <- stri_length(tr$replacement[tr$original == "question"])
max_length <- if (max_length < min_length)  min_length else max_length

# Shorten the strings and insert them into the data ----------------------------
text <- pd[[tr$replacement[tr$original == "question"]]]
text <- ifelse(stri_length(text) >= max_length, stri_c(strtrim(text, width=max_length-3), "..."), text)
pd[[tr$replacement[tr$original == "question"]]] <- text

# Divide the data for the two tables -------------------------------------------
first_table <- filter(pd, latent %in% latents[1:3]) %>%
               select(-latent) %>%
               xtable(digits=1)

second_table <- filter(pd, latent %in% latents[4:length(latents)]) %>%
                select(-latent) %>%
                xtable(digits=1)

# Capture output and alter to color negative values in red ---------------------
first_table <- capture.output(print.xtable(first_table, size="\\tiny", comment=F, include.rownames=F))
second_table <- capture.output(print.xtable(second_table, size="\\tiny", comment=F, include.rownames=F))

first_table <- stri_replace_all(first_table, "$1\\\\textcolor[HTML]{D2232B}{$2}", regex = "(\\s|^)(-\\d?\\d\\.\\d*)")
second_table <-  stri_replace_all(second_table, "$1\\\\textcolor[HTML]{D2232B}{$2}", "(\\s|^)(-\\d?\\d\\.\\d*)")

# Print the first table --------------------------------------------------------
cat(first_table, sep="\n")
```


```{r}
# Frametitle -------------------------------------------------------------------
cat("##", "","\n", sep=" ")

cat(second_table, sep="\n")
```

`r if(subentities == T) stri_c("# Resultat per", stri_trans_tolower(tr$replacement[tr$original == "subentity" & !is.na(tr$original)]), sep = " ")`

```{r, eval=subentities}
# Frametitle -------------------------------------------------------------------
cat("##", "", "\n", sep=" ")

# Get list of manifest names in correct order ----------------------------------
manifests <- data.frame("latent" = latents, stringsAsFactors = FALSE) %>%
             left_join(mutate(mm, latent = stri_trans_tolower(latent)), by = c("latent" = "latent"))

# Gather the data for the table ------------------------------------------------
pd <- df %>%
      select(mainentity, subentity, one_of(stri_c(stri_trans_tolower(manifests$manifest), "em"))) %>%
      filter(mainentity == entity) %>%
      mutate_each(funs(n = as.numeric(.)), -mainentity, -subentity) %>%
      bind_rows(mutate(., mainentity = stri_c(ent_sum, entity_short, sep = " ")), mutate(., mainentity = subentity)) %>%
      group_by(mainentity) %>%
      summarise_each(funs(m = mean(., na.rm = TRUE)))

# Convert to a longer format and convert to proper variable names --------------
pd <- pd %>%
      gather(manifest, score, -mainentity) %>% 
      mutate(manifest = stri_replace(manifest, "", regex = "[eE][mM]$")) %>%
      left_join(manifests, by = c("manifest" = "manifest")) %>%
      mutate(manifest = stri_replace(manifest, "Q", regex = "^q")) %>%
      mutate(manifest = factor(manifest, levels=unique(manifest))) %>%
      mutate(mainentity = factor(mainentity, levels = c(stri_c(ent_sum, entity_short, sep = " ")), unique(subentity), ordered = TRUE)) %>%
      select(latent, manifest, question, mainentity, score) %>%
      spread(mainentity, score, fill=0) %>%
      mutate(latent = factor(latent, levels = latents, ordered = TRUE)) %>%
      arrange(latent)

# Replace headers with the translation from config -----------------------------
names(pd) <- ordered_replace(names(pd), setNames(tr$original, tr$replacement))

# Fix encoding issues on windows -----------------------------------------------
if (Sys.info()[1] == "Windows") {
  names(pd) <- vapply(names(pd), function(x) {
    ifelse(Encoding(x) != "unknown", iconv(x, "UTF-8", "latin1"), x)}, character(1))
}

# Get length of column headers for the table, and truncate manifest text if needed:
max_length <- 110 - 2*length(names(pd)) - sum(stri_length(names(pd)[-2]))
max_length <- floor(max_length/5)*5

min_length <- stri_length(tr$replacement[tr$original == "question"])
max_length <- if (max_length < min_length)  min_length else max_length

# Shorten the strings and insert them into the data ----------------------------
text <- pd[[tr$replacement[tr$original == "question"]]]
text <- ifelse(stri_length(text) >= max_length, stri_c(strtrim(text, width=max_length-3), "..."), text)
pd[[tr$replacement[tr$original == "question"]]] <- text

# Divide the data for the two tables -------------------------------------------
first_table <- filter(pd, latent %in% latents[1:3]) %>%
               select(-latent) %>%
               xtable(digits=1)

second_table <- filter(pd, latent %in% latents[4:length(latents)]) %>%
                select(-latent) %>%
                xtable(digits=1)

# Capture output and alter to color negative values in red ---------------------
first_table <- capture.output(print.xtable(first_table, size="\\tiny", comment=F, include.rownames=F))
second_table <- capture.output(print.xtable(second_table, size="\\tiny", comment=F, include.rownames=F))

first_table <- stri_replace_all(first_table, "$1\\\\textcolor[HTML]{D2232B}{$2}", regex = "(\\s|^)(-\\d?\\d\\.\\d*)")
second_table <-  stri_replace_all(second_table, "$1\\\\textcolor[HTML]{D2232B}{$2}", regex = "(\\s|^)(-\\d?\\d\\.\\d*)")


# Print the first table --------------------------------------------------------
cat(first_table, sep="\n")
```


```{r, eval=subentities}
# Frametitle -------------------------------------------------------------------
cat("##", "", "\n", sep=" ")

cat(second_table, sep="\n")
```

# Påstander

```{r, eval=statement_metric}
## USED FOR METRIC STATEMENTS - TODO

# Frametitle -------------------------------------------------------------------
cat("##", "","\n", sep="")

# Get all statement vars and look for the unique ones (TODO: prep. for more than one statement section)
mvar <- stri_replace(mm$manifest[mm$latent == "statement_metric"], "$1", regex = "^(q[0-9]{1,2}).?") %>%
        na.omit() %>%
        unique()

# Get the manifests ------------------------------------------------------------
manifests <- mm %>%
             select(manifest, text) %>%
             filter(stri_detect(manifest, regex = stri_c("^", mvar), case_insensitive=TRUE)) %>%
             mutate(manifest = stri_trans_tolower(manifest))

# Gather the data for the table ------------------------------------------------
pd <- df %>%
      select(mainentity, starts_with(mvar)) %>%
      filter(mainentity == entity) %>%
      group_by(mainentity) %>%
      mutate_each(funs(rescale_score(clean_score(.))), -mainentity) %>%
      summarise_each(funs(m = mean(., na.rm=TRUE)), -mainentity)

# Add the contrast (average of the current or previous study) ------------------
if (contrast) {
  pd <- cd %>%
        select(starts_with(mvar), w) %>%
        mutate_each(funs(rescale_score(clean_score(.))), -w) %>%
        summarise_each(funs(m = weighted.mean(., w=w, na.rm=TRUE)), -w) %>%
        mutate(mainentity = ctr_sum) %>%
        bind_rows(pd, .)

} else {
  pd <- df %>%
        select(starts_with(mvar), w) %>%
        mutate_each(funs(rescale_score(clean_score(.))), -w) %>%
        summarise_each(funs(m = weighted.mean(., w=w, na.rm=TRUE)), -w) %>%
        mutate(mainentity = stu_sum) %>%
        bind_rows(pd, .)
}

# Convert to a longer format and convert to proper variable names --------------
pd %<>% gather(statement, score, -mainentity) %>%
        left_join(manifests, by=c("statement" = "manifest")) %>%
        mutate(text = stri_wrap(text, width = 40))

y_max <- ifelse(max(pd$score) < 90, round(max(pd$score)+10, -1), 100)
y_min <- ifelse(min(pd$score) > 10, round(min(pd$score)-10, -1), 0)

# Create the plot --------------------------------------------------------------
p <- ggplot(pd, aes(x=text, y=score, fill=mainentity, ymax=max(score)))
p + geom_bar(stat="identity", width=0.5, position=position_dodge(width=0.6)) + 
    scale_color_manual(values = setNames(palette, levels(pd$mainentity))) +
    scale_x_discrete(labels = function(x) stri_wrap(x, width = 15)) +
    geom_text(aes(label=format(round(score, 1))), position=position_dodge(width=0.6),
              size=3, colour="#23373b", vjust=-1.1) + 
    scale_y_continuous(limits=c(y_min,y_max), oob = rescale_none) +
    guides(fill = guide_legend(keywidth = .5, keyheight = .5)) +
    plot_theme()

```

```{r, eval=statement_categorical}
## USED FOR CATEGORICAL STATEMENTS - TODO

# Frametitle -------------------------------------------------------------------
cat("##", "","\n", sep="")

mvar <- stri_replace(mm$manifest[mm$latent == "statement_categorical"], "$1", regex = "^(q[0-9]{1,2}).?") %>%
        na.omit() %>%
        unique()

# Get the manifests ------------------------------------------------------------
manifests <- mm %>%
             select(manifest, question) %>%
             filter(stri_detect(manifest, regex = stri_c("^", mvar), case_insensitive = TRUE), manifest) %>%
             mutate(manifest = stri_trans_tolower(manifest))

# Gather the data for the table ------------------------------------------------
pd <- df %>%
      select(mainentity, starts_with(mvar)) %>%
      filter(mainentity == entity) %>%
      gather(statement, answer, -mainentity) %>%
      mutate(answer = factor(answer, 
              levels=unique(na.omit(answer)))) %>%
      count(mainentity, statement, answer) %>%
      filter(!is.na(answer)) %>%
      mutate(proportion = prop.table(n)) %>%
      select(-n) %>%
      spread(answer, proportion, fill = 0)

# Add the contrast (average of the current or previous study) ------------------
if (contrast) {
  pd <- cd %>%
        select(starts_with(mvar), w) %>%
        gather(statement, answer, -w) %>%
        mutate(answer = factor(answer, 
               levels=unique(na.omit(answer)))) %>%
        count(statement, answer, wt=w) %>%
        filter(!is.na(answer)) %>%
        mutate(proportion = prop.table(n)) %>%
        select(-n) %>%
        mutate(mainentity = ctr_sum) %>%
        spread(answer, proportion, fill = 0) %>%
        bind_rows(pd, .)

} else {
  pd <- df %>%
        select(starts_with(mvar), w) %>%
        gather(statement, answer, -w) %>%
        mutate(answer = factor(answer, 
                levels=unique(na.omit(answer)))) %>%
        count(statement, answer, wt=w) %>%
        filter(!is.na(answer)) %>%
        mutate(proportion = prop.table(n)) %>%
        select(-n) %>%
        mutate(mainentity = stu_sum) %>%
        spread(answer, proportion, fill = 0) %>%
        bind_rows(pd, .)
}

# Convert to a longer format and convert to proper variable names --------------
pd %<>% gather(answer, proportion, -mainentity, -statement) %>%
        left_join(manifests, by=c("statement" = "manifest")) %>%
        mutate(question = stri_wrap(question, width =40)) %>%
        mutate(mainentity = factor(as.character(mainentity), levels = c(entity, if (contrast) ctr_sum else stu_sum)))

# Create the plot --------------------------------------------------------------
p <- ggplot(pd, aes(x=answer, y=proportion, fill=mainentity, group=mainentity, ymin=0, ymax=1))
p + geom_bar(stat="identity", width=0.5, position=position_dodge(width=0.6)) +
    scale_fill_manual(values=setNames(palette, levels(pd$mainentity)), drop=FALSE) +
    facet_wrap(~ question, ncol=3, scales="free_x") +
    scale_x_discrete(labels = function(x) stri_wrap(x, width = 15)) + 
    scale_y_continuous(labels=percent) +
    geom_text(aes(label=stri_c(round(proportion*100, digits=0), "%")),  
              size=2, colour="#23373b", position=position_dodge(width=0.6), vjust=-1.1, hjust=.35) +
    guides(fill = guide_legend(keywidth = .5, keyheight = .5)) +
    plot_theme() + 
    theme(panel.grid = element_blank(),
          panel.margin = unit(2, "lines"))
```

# Anbefalingsadferd

```{r}
# Frametitle -------------------------------------------------------------------
cat("##", mm$question[stri_trans_tolower(mm$latent) %in% "loyal" & stri_detect(mm$manifest, regex = "15b$", case_insensitive = TRUE)], "\n", sep=" ")

# Add the contrast (average of the current or previous study) ------------------
if (contrast) {
  pd <- df %>% filter(mainentity == entity) %>% bind_rows(., mutate(cd, mainentity = ctr_sum))
} else {
  pd <- df %>% filter(mainentity == entity) %>% bind_rows(., mutate(df, mainentity = stu_sum))
}

# Get the variable name --------------------------------------------------------
mvar <- mm$manifest[stri_trans_tolower(mm$latent) %in% "loyal" & stri_detect(mm$manifest, regex = "15b$", case_insensitive = TRUE)]

# Gather the data --------------------------------------------------------------
pd <- pd %>%
      mutate(recom = pd[[stri_trans_tolower(mvar)]]) %>%
      select(mainentity, recom, w) %>%
      filter(!is.na(recom)) %>%
      mutate(w = as.numeric(w)) %>%
      mutate(recom = clean_score(recom)) %>%
      mutate(recom = ifelse(recom %in% 1:5L, "Negativ", ifelse(recom %in% 8:10L, "Positiv", "Nøytral"))) %>%
      count(mainentity, recom, wt = w) %>%
      mutate(proportion = prop.table(n)) %>%
      select(-n)

# Convert to proper format for plotting ----------------------------------------
pd <- pd %>%
      spread(recom, proportion, fill = 0) %>%
      gather(recom, proportion, -mainentity) %>%
      mutate(mainentity = factor(as.character(mainentity), levels = c(entity, if (contrast) ctr_sum else stu_sum)))

# Create the plot --------------------------------------------------------------
p <- ggplot(pd, aes(x=recom, y=proportion, fill=mainentity, group=mainentity, ymin=0, ymax=1))
p + geom_bar(stat="identity", width=0.5, position=position_dodge(width=0.6)) +
    scale_x_discrete(labels = function(x) stri_wrap(as.character(x), width = 15)) + 
    scale_y_continuous(labels=percent) +
    geom_text(aes(label=stri_c(round(proportion*100, digits=0), "%")),  
              size=3, colour="#23373b", position=position_dodge(width=0.6), vjust=-1.1, hjust=.35) +
    guides(fill = guide_legend(keywidth = .5, keyheight = .5)) +
    plot_theme() + 
    theme(title = element_text(hjust = -.1))

```


# Andel klager

```{r}
# Frametitle -------------------------------------------------------------------
cat("##", mm$question[mm$latent %in% "complaint"][1], "\n", sep=" ")

# Add the contrast (average of the current or previous study)
if (contrast) {
  pd <- df %>% filter(mainentity == entity) %>% bind_rows(., mutate(cd, mainentity = ctr_sum))
} else {
  pd <- df %>% filter(mainentity == entity) %>% bind_rows(., mutate(df, mainentity = stu_sum))
}

# Get the variable name --------------------------------------------------------
mvar <- mm$manifest[mm$latent %in% "complaint"]
mvar_values <- unlist(stri_split(mm$values[mm$manifest %in% mvar], regex = "\n"))

# Gather the data for the table ------------------------------------------------
pd <- pd %>%
      mutate(complaint = pd[[stri_trans_tolower(mvar)]]) %>%
      select(mainentity, complaint) %>%
      filter(!is.na(complaint)) %>%
      mutate(complaint = factor(complaint, levels = mvar_values, ordered = TRUE)) %>%
      count(mainentity, complaint) %>%
      mutate(proportion = prop.table(n)) %>%
      select(-n)

# Convert to proper format for plotting ----------------------------------------
pd <- pd %>%
      spread(complaint, proportion, fill = 0, drop = FALSE) %>%
      gather(complaint, proportion, -mainentity) %>%
      mutate(mainentity = factor(as.character(mainentity), levels = c(entity, if (contrast) ctr_sum else stu_sum)))

# Create the plot --------------------------------------------------------------
p <- ggplot(pd, aes(x=complaint, y=proportion, fill=mainentity, group=mainentity, ymin=0, ymax=1))
p + geom_bar(stat="identity", width=0.5, position=position_dodge(width=0.6)) +
    scale_x_discrete(labels = function(x) stri_wrap(as.character(x), width = 15)) + 
    scale_y_continuous(labels=percent) +
    geom_text(aes(label=stri_c(round(proportion*100, digits=0), "%")),  
              size=3, colour="#23373b", position=position_dodge(width=0.6), vjust=-1.1, hjust=.35) +
    guides(fill = guide_legend(keywidth = .5, keyheight = .5)) +
    plot_theme() + 
    theme(title = element_text(hjust = -.1))

```

# Klager

```{r, eval=complaint}
# Frametitle -------------------------------------------------------------------
frametitle <- cat("##", mm$question[mm$latent %in% c("open_complaint", "open_wouldcomplain")][1], "\n", sep=" ")

# Variable ---------------------------------------------------------------------
mvar <- mm$manifest[mm$latent %in% c("open_complaint", "open_wouldcomplain")]

pd <- df %>%
      select(mainentity, one_of(stri_trans_tolower(mvar))) %>%
      gather(var, answers, -mainentity) %>%
      filter(mainentity == entity & !is.na(answers)) %>%
      mutate(answers = stri_replace(answers, "", regex = "^[ [:punct:]]*")) %>%
      mutate(answers = stri_c("- ", answers)) %>%
      mutate(nchars = stri_length(answers), nlines = ceiling(nchars/135), tlines = cumsum(nlines)) %>%
      mutate(page = ifelse(tlines <= 23, 1, ifelse(tlines <= 46 & tlines > 23, 2, 3)))

# Inform if no answers were found ----------------------------------------------
if (nrow(pd) == 0) {
  
  cat(frametitle, "Ingen årsaker oppgitt av respondentene.", sep="\n")

  # Write to sheet if text is too long (>3 pages) ------------------------------
  } else if (max(pd$tlines) > 69) {
  
  cat(frametitle, "Se vedlagt regneark i Excel format.", sep="\n")
  pd %>% mutate(answers = stri_replace(answers, "", regex = "^- ")) %>%
         select("Svar" = answers) %>%
         to_sheet(wb, title = frametitle, sheet = "Klager")
  
  # Print the results ----------------------------------------------------------
  } else {

  for (i in unique(pd$page)) { cat(frametitle, pd$answers[pd$page == i], "\n", sep="\n") }
  
  }

# Make sure changes to WB are registered ---------------------------------------
wb <- wb
```

# Åpne svar

```{r, eval=open_answer}
# Frametitle -------------------------------------------------------------------
frametitle <- stri_c("##", mm$question[mm$latent %in% "open_answer"][1], "(uredigerte svar)", sep = " ")

# Variable ---------------------------------------------------------------------
mvar <- mm$manifest[mm$latent %in% "open_answer"]

pd <- df %>%
      select(mainentity, one_of(stri_trans_tolower(mvar))) %>%
      gather(var, answers, -mainentity) %>%
      filter(mainentity == entity & !is.na(answers)) %>%
      mutate(answers = stri_replace(answers, "", regex = "^[ [:punct:]]*")) %>%
      mutate(answers = stri_c("- ", answers)) %>%
      mutate(nchars = stri_length(answers), nlines = ceiling(nchars/135), tlines = cumsum(nlines)) %>%
      mutate(page = ifelse(tlines <= 23, 1, ifelse(tlines <= 46 & tlines > 23, 2, 3)))

# Inform if no answers were found ----------------------------------------------
if (nrow(pd) == 0) {
  
  cat(frametitle, "Ingen årsaker oppgitt av respondentene.", sep="\n")

  # Write to sheet if text is too long (>3 pages) ------------------------------
  } else if (max(pd$tlines) > 69) {
  
  cat(frametitle, "Se vedlagt regneark i Excel format.", sep="\n")
  pd %>% mutate(answers = stri_replace(answers, "", regex = "^- ")) %>%
         select("Svar" = answers) %>%
         to_sheet(wb, title = frametitle, sheet = "Åpne svar")
  
  # Print the results ----------------------------------------------------------
  } else {

  for (i in unique(pd$page)) { cat(frametitle, pd$answers[pd$page == i], "\n", sep="\n") }
  
  }

# Make sure changes to WB are registered ---------------------------------------
wb <- wb
```

```{r, eval=oa_positive}
# Frametitle -------------------------------------------------------------------
frametitle <- stri_c("##", mm$question[mm$latent %in% "oa_positive"][1], "(uredigerte svar)", sep = " ")

# Variable ---------------------------------------------------------------------
mvar <- mm$manifest[mm$latent %in% "oa_positive"]

pd <- df %>%
      select(mainentity, one_of(stri_trans_tolower(mvar))) %>%
      gather(var, answers, -mainentity) %>%
      filter(mainentity == entity & !is.na(answers)) %>%
      mutate(answers = stri_replace(answers, "", regex = "^[ [:punct:]]*")) %>%
      mutate(answers = stri_c("- ", answers)) %>%
      mutate(nchars = stri_length(answers), nlines = ceiling(nchars/135), tlines = cumsum(nlines)) %>%
      mutate(page = ifelse(tlines <= 23, 1, ifelse(tlines <= 46 & tlines > 23, 2, 3)))

# Inform if no answers were found ----------------------------------------------
if (nrow(pd) == 0) {
  
  cat(frametitle, "Ingen årsaker oppgitt av respondentene.", sep="\n")

  # Write to sheet if text is too long (>3 pages) ------------------------------
  } else if (max(pd$tlines) > 69) {
  
  cat(frametitle, "Se vedlagt regneark i Excel format.", sep="\n")
  pd %>% mutate(answers = stri_replace(answers, "", regex = "^- ")) %>%
         select("Svar" = answers) %>%
         to_sheet(wb, title = frametitle, sheet = "Positivt")
  
  # Print the results ----------------------------------------------------------
  } else {

  for (i in unique(pd$page)) { cat(frametitle, pd$answers[pd$page == i], "\n", sep="\n") }
  
  }

# Make sure changes to WB are registered ---------------------------------------
wb <- wb
```

```{r, eval=oa_negative}
# Frametitle -------------------------------------------------------------------
frametitle <- stri_c("##", mm$question[mm$latent == "oa_negative" & !is.na(mm$latent)][1], "(uredigerte svar)", sep = " ")

# Variable ---------------------------------------------------------------------
mvar <- mm$manifest[mm$latent %in% "oa_negative"]

pd <- df %>%
      select(mainentity, one_of(stri_trans_tolower(mvar))) %>%
      gather(var, answers, -mainentity) %>%
      filter(mainentity == entity & !is.na(answers)) %>%
      mutate(answers = stri_replace(answers, "", regex = "^[ [:punct:]]*")) %>%
      mutate(answers = stri_c("- ", answers)) %>%
      mutate(nchars = stri_length(answers), nlines = ceiling(nchars/135), tlines = cumsum(nlines)) %>%
      mutate(page = ifelse(tlines <= 23, 1, ifelse(tlines <= 46 & tlines > 23, 2, 3)))

# Inform if no answers were found ----------------------------------------------
if (nrow(pd) == 0) {
  
  cat(frametitle, "Ingen årsaker oppgitt av respondentene.", sep="\n")

  # Write to sheet if text is too long (>3 pages) ------------------------------
  } else if (max(pd$tlines) > 69) {
  
  cat(frametitle, "Se vedlagt regneark i Excel format.", sep="\n")
  pd %>% mutate(answers = stri_replace(answers, "", regex = "^- ")) %>%
         select("Svar" = answers) %>%
         to_sheet(wb, title = frametitle, sheet = "Forbedring")
  
  # Print the results ----------------------------------------------------------
  } else {

  for (i in unique(pd$page)) { cat(frametitle, pd$answers[pd$page == i], "\n", sep="\n") }
  
  }

# Make sure changes to WB are registered ---------------------------------------
wb <- wb
```

```{r, results='hide'}
# Write the wb if necessary ----------------------------------------------------
if (length(sheets(wb))) {
  saveWorkbook(wb, stri_c("../Reports/", entity, " - åpne svar.xlsx"), overwrite = TRUE)
}
```

