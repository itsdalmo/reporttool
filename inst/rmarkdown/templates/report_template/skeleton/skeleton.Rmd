---
title: "Customer satisfaction"
subtitle: "REPLACE_ENTITY"
author: "EPSI Norge"
date: "REPLACE_DATE"
output: 
  reporttool::beamer_template
---

```{r, error=FALSE, results='hide'}

# Replace entity and path to data ----------------------------------------------

input <- "REPLACE_DATA"
entity <- "REPLACE_ENTITY"

# Package dependencies ---------------------------------------------------------

# Reading and manipulating data
suppressMessages(require(reporttool))
suppressMessages(require(openxlsx))
suppressMessages(require(dplyr))
suppressMessages(require(tidyr))
suppressMessages(require(magrittr))
suppressMessages(require(lubridate))

# Plotting
suppressMessages(require(ggplot2))
suppressMessages(require(grid))
suppressMessages(require(scales))

# Latex tables and string formatting
suppressMessages(require(xtable))
suppressMessages(require(stringr))

# Default values --------------------------------------------------------------

latents <- rt_defaults("latent_names")
palette <- rt_defaults("ggcolors")
cutoff <- .3

# Load the data if necessary --------------------------------------------------
# (Could already be loaded by reporttool::generate_report)

if (!all(exists("df"), exists("mm"), exists("ents"))) {
  data <- get_survey(input)
  for(i in names(data)) { assign(i, data[[i]]) }
}

# Remove common suffixes in entity names (e.g, "barnehage")
if (!is.na(cf$replacement[cf$original == "entity_short"])) {
  entity_short <- sub(paste0(" ?", cf$replacement[cf$original == "entity_short"], "[^ ]+ ?"), "", entity, ignore.case=TRUE)
} else {
  entity_short <- entity
}

# Get names for averages and chunk eval options -------------------------------
ent_sum <- cf$replacement[cf$original == "average"]
ctr_sum <- cf$replacement[cf$original == "contrast_average"]
stu_sum <- cf$replacement[cf$original == "study_average"]


# See if the entity has any historical data and/or contrast data exists (True/False):
historical <- if (exists("hd")) entity %in% hd$mainentity else FALSE
contrast <- if (exists("cd")) nrow(cd) > 0 else FALSE
subentities <- "subentity" %in% names(df)

# Check if any statements should be plotted (metric or categorical)
statement_metric <- "statement_metric" %in% tolower(mm$latent)
statement_categorical <- "statement_categorical" %in% tolower(mm$latent)

# Check variables for open answers in complaints
complaint <- any(c("open_complaint", "open_wouldcomplain") %in% tolower(mm$latent))
open_noncomplaint <- "open_noncomplaint" %in% tolower(mm$latent)
open_wouldcomplain <- "open_wouldcomplain" %in% tolower(mm$latent)
oa_positive <- "oa_positive" %in% tolower(mm$latent)
oa_negative <- "oa_negative" %in% tolower(mm$latent)
open_answer <- "open_answer" %in% tolower(mm$latent)
```

```{r, error=FALSE, results='hide'}
# Convert date columns and get collection dates
df %<>% mutate_each(funs(dt = convertToDateTime(as.numeric(.))), start_date, end_date) %>%
        mutate_each(funs(dt = ymd_hms(.)), start_date, end_date)

survey <- df %>% 
          filter(mainentity == entity) %>%
          summarise(start = format(min(start_date, na.rm=TRUE), "%e. %b. %Y"),
                    end = format(max(start_date, na.rm=TRUE), "%e. %b. %Y"),
                    time = min(start_date, na.rm=TRUE)) %>%
          mutate(month = format(time, "%m"), year = format(time, "%Y")) %>% 
          mutate(period = paste(ifelse(month <= 6, 
                                cf$replacement[cf$original == "spring"], 
                                cf$replacement[cf$original == "fall"]),
                                year))
  
# Response information
respondents <- df %>%
               filter(mainentity == entity) %>%
               mutate(total = n()) %>%
               filter(percent_missing <= cutoff) %>%
               mutate(valid = n()) %>%
               summarise(total = mean(total, na.rm=TRUE), valid = mean(valid, na.rm=TRUE)) %>%
               mutate(valid_percent = round((valid/total)*100, digits=0))
  
# Response per subentity (if specified)
if (subentities) {
      valid_sub <- df %>%
                 filter(mainentity == entity & percent_missing <= cutoff) %>%
                 group_by(subentity) %>%
                 summarise(valid = n()) %>%
                 mutate(valid = paste(subentity, valid))
}


# Remove incomplete observations
df %<>% filter(percent_missing <= cutoff)

# Number of latents and model questions     
lat_info <- mm %>%
            filter(tolower(latent) %in% latents) %>% 
            count(latent) %>%
            summarise(low = min(n), high = max(n), model = sum(n)) %>%
            mutate(total = nrow(filter(mm, grepl(paste0("^[qbk]"), manifest, ignore.case=TRUE) & !grepl("em$", manifest))))
```

# Forord
## Gjennomføring

- Målgruppen for denne undersøkelsen er foreldre med barn i `r entity`.
- Svarene er avgitt på web i perioden `r survey$start` til `r survey$end`, og er gjort via Research.net[^1].
- Respondentene (de som er invitert til å delta) kan potensielt motta 3 e-poster - hvorav den første er en standard utsendelse, samt 2 påminnelser til de som ikke svarte på den første utsendelsen og evt. den første påminnelsen.
- Av de `r respondents$total` inviterte har totalt `r respondents$valid` svart (`r paste0(respondents$valid_percent, "%")`). 
`r if (subentities) paste0("- ", "Svarprosent per ", tolower(cf$replacement[cf$original == "subentity"]), ": ", paste(valid_sub$res, collapse = ", "))`
- Det er hentet inn svar på `r lat_info$model` spørsmål som bygger opp under hovedanalysen. I tillegg til dette så har det vært stilt inntil `r lat_info$total-lat_info$model` spørsmål som bidrar med ytterligere innsikt i forhold til kundeopplevelsen (totalt `r lat_info$total`). 
- Tilsvarende studier gjennomføres ved en rekke andre norske barnehager.
- Alle resultatene som presenteres i denne rapporten er overlevert for bruk ved `r entity`.
- Du står selv fritt til å dele resultatene med andre.
- I motsetning til de nasjonale studiene så vil ikke resultatene fra den enkelte barnehage bli publisert i det offentlige rom av EPSI. 
- EPSIs nasjonale studie av offentlige tjenester (inkl. private og kommunale barnehager) er en separat studie, og resultatene som formidles via EPSIs hjemmesider[^2] kan fritt siteres. Enkelte resultater fra den nasjonale studien (snitt nasjonal) er inkludert i denne rapporten.

[^1]: [http://surveymonkey.com](http://surveymonkey.com)
[^2]: [http://epsi-norway.org](http://epsi-norway.org)


## Skala og svar


- Indeksen for kundetilfredshet presenteres som en verdi mellom 0 og 100, og er det sentrale målet i disse målingene. Dette er en indeksverdi, ikke en prosentverdi. Jo høyere verdi desto bedre anser kundene at banken oppfyller deres krav og forventninger. 
- Spørsmålene svares på en skala fra 1 til 10, hvor 1 betyr "helt uenig" eller "veldig misfornøyd" og hvor 10 betyr "helt enig" eller "veldig fornøyd".
- Resultatene gjøres i etterkant om til en 100-punkts skala.

- Som en generell regel kan man si at:
    - Målinger under 60 er lavt/veldig lavt (vanskeligheter med å motivere kundene til å bli).
    - Målinger fra 60 - 75 er gjennomsnittlig  
    - Målinger over 75 anses som høyt/veldig høyt (peker på en sterk relasjon mellom bankkontoret og kundene).  

- Som en tommelfingerregel så er forskjeller på mer enn 3 poeng signifikante. Dette innebærer at man med en viss grad av sikkerhet kan si at forskjellen mellom to indeksverdier er for stor til å være tilfeldig. 
- Se www.epsi-norway.org for mer informasjon om metode og modell, eller om EPSI for øvrig.

## Aspekter i EPSI modellen

- **`r cf$replacement[tolower(cf$original) == "image"]`** (`r mm$manifest[tolower(mm$latent) %in% "image"]`)  er målt for å gi en forståelse av hvordan respondentene oppfatter at `r entity` vurderes av andre som har kjennskap til barnehagen. 

- **`r cf$replacement[tolower(cf$original) == "expect"]`** (`r mm$manifest[tolower(mm$latent) %in% "expect"]`) er et mål på hva respondentene forventer å få ut av kundeforholdet.

- **`r cf$replacement[tolower(cf$original) == "prodq"]`** (`r mm$manifest[tolower(mm$latent) %in% "prodq"]`) fanger respondentens opplevelse av tjeneste- og produkttilbudet.

- **`r cf$replacement[tolower(cf$original) == "servq"]`** (`r mm$manifest[tolower(mm$latent) %in% "servq"]`) har fokus på forholdet mellom respondentene og de ansatte når det gjelder opplevelsen av service og det mer mellommenneskelige.

- **`r cf$replacement[tolower(cf$original) == "value"]`** (`r mm$manifest[tolower(mm$latent) %in% "value"]`) er utformet for å fange opp forholdet mellom hva som er oppnådd (levert) og prisen / kostnaden for å få dette, sett fra respondentenes ståsted. 

- **`r cf$replacement[tolower(cf$original) == "epsi"]`** (KTI) er det sentrale målet i modellen, og reflekterer hvorvidt kundene opplever at deres krav og forventninger blir oppfylt. Resultatet for barnehagen beregnes på bakgrunn av `r length(mm$manifest[tolower(mm$latent) %in% "epsi"])` spørsmål (`r mm$manifest[tolower(mm$latent) %in% "epsi"]`).

- **`r cf$replacement[tolower(cf$original) == "loyal"]`** (`r mm$manifest[tolower(mm$latent) %in% "loyal"]`) måler eksempelvis hvorvidt respondenten ville valgt samme barnehage dersom vedkommende måtte velge på nytt. Forskning viser at lojalitet i stor grad er påvirket av kundetilfredsheten.

- Generelt så er det viktig med en balanse mellom forventninger og opplevd kvalitet (selve leveransen). Med andre ord, dersom gapet mellom hva kundene forventer og hvordan de opplever kvaliteten (negativt gap) blir for stor så vil det ha negativ betydning på tilfredsheten med barnehagen.

- **NB**: I spørsmålsteksten er EB benyttet som en plassholder. Da respondentene svarte på undersøkelsen ble dette feltet byttet ut med navnet på barnehagen (altså `r entity`).


# Kundeprofil for `r entity`

```{r}
# Frametitle
cat("##", "","\n", sep=" ")

# Add the contrast (average of the current or previous study)
if (contrast) {
  pd <- df %>% filter(mainentity == entity) %>% bind_rows(., mutate(cd, mainentity = ctr_sum))
} else {
  pd <- df %>% filter(mainentity == entity) %>% bind_rows(., mutate(df, mainentity = stu_sum))
}

# Gather the data for the table
pd <- pd %>%
      select(mainentity, one_of(latents), w) %>%
      mutate_each(funs(n = as.numeric(.)), -mainentity) %>%
      group_by(mainentity) %>%
      summarise_each(funs(wm = weighted.mean(., w=w, na.rm = TRUE)), -w)

# Convert to proper format for plotting
pd <- pd %>% 
      gather(latent, score, -mainentity) %>%
      mutate(latent = as.character(latent)) %>%
      left_join(cf, by = c("latent" = "original")) %>%
      mutate(latent = factor(replacement, levels=unique(replacement)), ordered = TRUE) %>%
      mutate(mainentity = factor(mainentity, levels = c(entity, if (contrast) ctr_sum else stu_sum), ordered = TRUE)) %>%
      select(mainentity, latent, score)

# Get the vertical justification for geom text
vjust <- pd %>% spread(mainentity, score)
vjust$overlap <- if (ncol(vjust) > 3) rowMeans(vjust[, 2:ncol(vjust)]) else vjust[[ncol(vjust)]]
vjust <- ifelse(vjust[[entity]] < vjust[["overlap"]], "2", "-1")

# Calculate appropriate range for y-axis
y_max <- ifelse(max(pd[["score"]]) < 90, round(max(pd[["score"]])+10, -1), 100)
y_min <- ifelse(min(pd[["score"]]) > 10, round(min(pd["score"])-10, -1), 0)

# Create the profile-plot
p <- ggplot(data=pd, aes(x=latent, y=score, group=mainentity, colour=mainentity))
p + geom_line(size=1) +
    geom_point(size=3) +
    scale_color_manual(values = setNames(palette, unique(pd$mainentity))) +
    geom_text(data = filter(pd, mainentity == entity), 
              aes(label=format(round(score, 1))),  
              size=4, colour="#23373b", vjust=vjust) + 
    ylim(y_min, y_max) + 
    plot_theme()
```

`r if(subentities == T) paste("# Profil per", tolower(cf$replacement[cf$original == "subentity" & !is.na(cf$original)]))`

```{r, eval=subentities}
# Frametitle
cat("##", "","\n", sep=" ")

# Gather the data for the table
pd <- pd %>%
      select(mainentity, subentity, one_of(latents)) %>%
      filter(mainentity == entity) %>%
      mutate_each(funs(n = as.numeric(.)), -mainentity, -subentity) %>%
      bind_rows(mutate(., mainentity = paste(ent_sum, entity_short)), mutate(., mainentity = subentity)) %>%
      group_by(mainentity) %>%
      summarise_each(funs(m = mean(., na.rm = TRUE)))
      
# Convert to proper format for plotting
pd <- pd %>% 
      gather(latent, score, -mainentity, -subentity) %>%
      mutate(latent = as.character(latent)) %>%
      left_join(cf, by = c("latent" = "original")) %>%
      mutate(latent = factor(replacement, levels=unique(replacement)), ordered = TRUE) %>%
      mutate(mainentity = factor(mainentity, levels = c(paste(ent_sum, entity_short)), unique(subentity), ordered = TRUE)) %>%
      select(mainentity, latent, score)

# Get the vertical justification for geom text
vjust <- pd %>% spread(mainentity, score)
vjust$overlap <- if (ncol(vjust) > 3) rowMeans(vjust[, 2:ncol(vjust)]) else vjust[[ncol(vjust)]]
vjust <- ifelse(vjust[[entity]] < vjust[["overlap"]], "2", "-1")

# Calculate appropriate range for y-axis
y_max <- ifelse(max(pd[["score"]]) < 90, round(max(pd[["score"]])+10, -1), 100)
y_min <- ifelse(min(pd[["score"]]) > 10, round(min(pd["score"])-10, -1), 0)

# Make the average a dashed line
pd$lines <- ifelse(pd$mainentity == paste(ent_sum, entity_short), "solid", "dashed")

# Create the profile-plot
p <- ggplot(data=pd, aes(x=latent, y=score, group=mainentity, colour=mainentity, linetype=lines))
p + geom_line(size=1) +
    geom_point(size=3) +
    scale_color_manual(values = setNames(palette, unique(pd$mainentity))) +
    geom_text(data = filter(pd, mainentity == paste(ent_sum, entity_short)), 
              aes(label=format(round(score, 1))),  
              size=4, colour="#23373b", vjust=vjust) + 
    ylim(y_min, y_max) + 
    guides(linetype=FALSE) +
    plot_theme()
```

`r if(historical == T) paste("# Historisk profil for", entity)`

```{r, eval=historical}
# Frametitle
cat("##", "","\n", sep=" ")

# Gather the data for plotting
pd <- hd %>%
      select(semester, year, mainentity, subentity, one_of(latents)) %>%
      filter(mainentity == entity, subentity == ent_sum) %>%
      arrange(desc(year), semester) %>%
      mutate(semester = ifelse(tolower(semester) == "spring", 
                               cf$replacement[cf$original == "spring"], semester)) %>%
      mutate(semester = ifelse(tolower(semester) == "fall", 
                               cf$replacement[cf$original == "fall"], semester)) %>%
      mutate(mainentity = paste(semester, year)) %>%
      select(-semester, -year, -subentity) %>%
      mutate_each(funs(num = as.numeric(.)), -mainentity)
  

pd <- df %>%
      select(mainentity, one_of(latents)) %>%
      filter(mainentity == entity) %>%
      group_by(mainentity) %>% 
      summarise_each(funs(m = mean(as.numeric(.), na.rm=T))) %>%
      mutate("mainentity" = survey$period[1]) %>%
      bind_rows(., pd)

# Convert to proper format for plotting
pd <- pd %>%
      gather(latent, score, -mainentity) %>%
      mutate(latent = as.character(latent)) %>%
      left_join(cf, by = c("latent" = "original")) %>%
      mutate(latent = factor(replacement, levels=unique(replacement))) %>%
      mutate(mainentity = factor(mainentity, levels=unique(mainentity))) %>%
      select(mainentity, latent, score)

# Get the vertical justification for geom text
vjust <- pd %>% spread(mainentity, score)
vjust$overlap <- if (ncol(vjust) > 3) rowMeans(vjust[, 2:ncol(vjust)]) else vjust[[ncol(vjust)]]
vjust <- ifelse(vjust[[entity]] < vjust[["overlap"]], "2", "-1")

# Calculate appropriate range for y-axis
y_max <- ifelse(max(pd[["score"]]) < 90, round(max(pd[["score"]])+10, -1), 100)
y_min <- ifelse(min(pd[["score"]]) > 10, round(min(pd["score"])-10, -1), 0)

# Create the profile-plot
p <- ggplot(data=pd, aes(x=latent, y=score, group=mainentity, colour=mainentity))
p + geom_line(size=1) +
    scale_color_manual(values = setNames(palette, levels(pd$mainentity))) +
    geom_point(size=3) +
    geom_text(data = filter(pd, mainentity == survey$period[1]), 
              aes(label=format(round(score, 1))),  
              size=4, colour="#23373b", vjust=vjust) + 
    ylim(y_min, y_max) + 
    plot_theme()
```

# SWOT

```{r}
# Frametitle
if (contrast) {
  cat("##", "Differansen mellom", entity, "og", tolower(ctr_sum) ,"\n", sep=" ")
} else {
  cat("##", "Differansen mellom", entity, "og", tolower(stu_sum) ,"\n", sep=" ")
}

# Get list of manifest names in correct order.
manifests <- data.frame("latent" = latents, stringsAsFactors = FALSE) %>%
             left_join(mutate(mm, latent = tolower(latent)), by = c("latent" = "latent")) %>%
             mutate(question = ifelse(str_length(question) >= 90, paste0(strtrim(question, width=90-3), "..."), question))


# Add the contrast (average of the current or previous study)
if (contrast) {
  pd <- df %>% filter(mainentity == entity) %>% bind_rows(., mutate(cd, mainentity = ctr_sum))
} else {
  pd <- df %>% filter(mainentity == entity) %>% bind_rows(., mutate(df, mainentity = stu_sum))
}

# Gather the data for the table
pd <- pd %>%
      select(mainentity, one_of(paste0(tolower(manifests$manifest), "em")), w) %>%
      group_by(mainentity) %>%
      summarise_each(funs(wm = weighted.mean(as.numeric(.), w=w, na.rm=T)), -w)

# Convert to a longer format and convert to proper variable names.
pd <- pd %>%
      gather(manifest, score, -mainentity) %>% 
      mutate(manifest = gsub("em$|EM$", "", manifest)) %>%
      left_join(manifests, by = c("manifest" = "manifest")) %>%
      mutate(manifest = gsub("^q", "Q", manifest)) %>%
      mutate(manifest = factor(manifest, levels=unique(manifest))) %>%
      mutate(mainentity = factor(mainentity, levels = c(entity, if (contrast) ctr_sum else stu_sum), ordered = TRUE)) %>%
      spread(mainentity, score, fill=0)

# Calculate the difference between the entity and the average
if (stu_sum %in% names(pd)) {
    pd$difference <- pd[[entity]] - pd[[stu_sum]]
    pd$difference[pd[[stu_sum]] == 0] <- NA
} 

if (ctr_sum %in% names(pd)) {
  pd$difference <- pd[[entity]] - pd[[ctr_sum]]
  pd$difference[pd[[ctr_sum]] == 0] <- NA
}

# Ready the data for plotting
pd <- pd %>%
      select(manifest, question, difference) %>%
      mutate("sign" = ifelse(difference > 0, 1, 0)) %>%
      mutate(sign = factor(sign, levels=unique(sign))) %>%
      mutate(question = paste(manifest, question, sep = " - ")) %>%
      mutate(question = factor(question, levels=rev(unique(question))))

# Calculate appropriate range for y-axis
y_min <- 5*floor(min(pd$difference, na.rm=TRUE)/4)
y_max <- 5*ceiling(max(pd$difference, na.rm=TRUE)/4)

# Create the plot
p <- ggplot(data=pd, aes(x=question, y=difference, fill=sign))
p + geom_bar(stat="identity", width=0.5, position="dodge") + 
    coord_flip(ylim = c(y_min, y_max)) +
    scale_fill_manual(values=setNames(palette, c(0,1))) +
    geom_hline(xintercept=0, size=.5, colour = "#D0D0D0") +
    geom_text(data = filter(pd, sign == 1), 
              aes(label=format(round(difference, 1))),  
              size=3, colour="#23373b", vjust=.2, hjust=-.55) +
    geom_text(data = filter(pd, sign == 0), 
              aes(label=format(round(difference, 1))),  
              size=3, colour="#23373b", vjust=.3, hjust=+1.5) +
    plot_theme(legend="none") + 
    theme(plot.margin = unit(c(1, 1.5, 0.5, 0.5), "lines"),
          axis.text.x = element_text(angle = 45, hjust = 1),
          panel.grid = element_blank())
```


# Resultat per spørsmål

```{r}
# Frametitle
if (contrast) {
  cat("##", "Differansen mellom", entity, "og", tolower(ctr_sum) ,"\n", sep=" ")
} else {
  cat("##", "Differansen mellom", entity, "og", tolower(stu_sum) ,"\n", sep=" ")
}

# Get list of manifest names in correct order.
manifests <- data.frame("latent" = latents, stringsAsFactors = FALSE) %>%
             left_join(mutate(mm, latent = tolower(latent)), by = c("latent" = "latent"))


# Add the contrast (average of the current or previous study)
if (contrast) {
  pd <- df %>% filter(mainentity == entity) %>% bind_rows(., mutate(cd, mainentity = ctr_sum))
} else {
  pd <- df %>% filter(mainentity == entity) %>% bind_rows(., mutate(df, mainentity = stu_sum))
}

# Gather the data for the table
pd <- pd %>%
      select(mainentity, one_of(paste0(tolower(manifests$manifest), "em")), w) %>%
      group_by(mainentity) %>%
      summarise_each(funs(wm = weighted.mean(as.numeric(.), w=w, na.rm=T)), -w)

# Convert to a longer format and convert to proper variable names.
pd <- pd %>%
      gather(manifest, score, -mainentity) %>% 
      mutate(manifest = gsub("em$|EM$", "", manifest)) %>%
      left_join(manifests, by = c("manifest" = "manifest")) %>%
      mutate(manifest = gsub("^q", "Q", manifest)) %>%
      mutate(manifest = factor(manifest, levels=unique(manifest))) %>%
      mutate(mainentity = factor(mainentity, levels = c(entity, if (contrast) ctr_sum else stu_sum), ordered = TRUE)) %>%
      select(latent, manifest, question, mainentity, score) %>%
      spread(mainentity, score, fill=0) %>%
      mutate(latent = factor(latent, levels = latents, ordered = TRUE)) %>%
      arrange(latent)

# Calculate the difference between the entity and the average
if (stu_sum %in% names(pd)) {
    pd$difference <- pd[[entity]] - pd[[stu_sum]]
    pd$difference[pd[[stu_sum]] == 0] <- NA
} 

if (ctr_sum %in% names(pd)) {
  pd$difference <- pd[[entity]] - pd[[ctr_sum]]
  pd$difference[pd[[ctr_sum]] == 0] <- NA
}

# Replace headers with the translation from config
names(pd) <- ordered_replace(names(pd), setNames(cf$original, cf$replacement))

# Fix encoding issues on windows
if (Sys.info()[1] == "Windows") {
  names(pd) <- vapply(names(pd), function(x) {
    ifelse(Encoding(x) != "unknown", iconv(x, "UTF-8", "latin1"), x)}, character(1))
}

# Get length of column headers for the table, and truncate manifest text if needed:
max_length <- 110 - 2*length(names(pd)) - sum(str_length(names(pd)[-2]))
max_length <- floor(max_length/5)*5

min_length <- str_length(cf$replacement[cf$original == "question"])
max_length <- if (max_length < min_length)  min_length else max_length

# Shorten the strings and insert them into the data
text <- pd[[cf$replacement[cf$original == "question"]]]
text <- ifelse(str_length(text) >= max_length, paste0(strtrim(text, width=max_length-3), "..."), text)
pd[[cf$replacement[cf$original == "question"]]] <- text

# Divide the data for the two tables
first_table <- filter(pd, latent %in% latents[1:3]) %>%
               select(-latent) %>%
               xtable(digits=1)

second_table <- filter(pd, latent %in% latents[4:length(latents)]) %>%
                select(-latent) %>%
                xtable(digits=1)

# Capture output and alter to color negative values in red.
first_table <- capture.output(print.xtable(first_table, size="\\tiny", comment=F, include.rownames=F))
second_table <- capture.output(print.xtable(second_table, size="\\tiny", comment=F, include.rownames=F))

first_table <- gsub("(\\s|^)(-\\d?\\d\\.\\d*)", "\\1\\\\textcolor[HTML]{D2232B}{\\2}", first_table)
second_table <-  gsub("(\\s|^)(-\\d?\\d\\.\\d*)", "\\1\\\\textcolor[HTML]{D2232B}{\\2}", second_table)

# Print the first table
cat(first_table, sep="\n")
```


```{r}
# Frametitle
cat("##", "","\n", sep=" ")

cat(second_table, sep="\n")
```

`r if(subentities == T) paste("# Resultat per", tolower(cf$replacement[cf$original == "subentity" & !is.na(cf$original)]))`

```{r, eval=subentities}
# Frametitle
cat("##", "", "\n", sep=" ")

# Get list of manifest names in correct order.
manifests <- data.frame("latent" = latents, stringsAsFactors = FALSE) %>%
             left_join(mutate(mm, latent = tolower(latent)), by = c("latent" = "latent"))

# Gather the data for the table
pd <- df %>%
      select(mainentity, subentity, one_of(paste0(tolower(manifests$manifest), "em"))) %>%
      filter(mainentity == entity) %>%
      mutate_each(funs(n = as.numeric(.)), -mainentity, -subentity) %>%
      bind_rows(mutate(., mainentity = paste(ent_sum, entity_short)), mutate(., mainentity = subentity)) %>%
      group_by(mainentity) %>%
      summarise_each(funs(m = mean(., na.rm = TRUE)))
      
# Convert to a longer format and convert to proper variable names.
pd <- pd %>%
      gather(manifest, score, -mainentity) %>% 
      mutate(manifest = gsub("em$|EM$", "", manifest)) %>%
      left_join(manifests, by = c("manifest" = "manifest")) %>%
      mutate(manifest = gsub("^q", "Q", manifest)) %>%
      mutate(manifest = factor(manifest, levels=unique(manifest))) %>%
      mutate(mainentity = factor(mainentity, levels = c(paste(ent_sum, entity_short)), unique(subentity), ordered = TRUE)) %>%
      select(latent, manifest, question, mainentity, score) %>%
      spread(mainentity, score, fill=0) %>%
      mutate(latent = factor(latent, levels = latents, ordered = TRUE)) %>%
      arrange(latent)

# Replace headers with the translation from config
names(pd) <- ordered_replace(names(pd), setNames(cf$original, cf$replacement))

# Fix encoding issues on windows
if (Sys.info()[1] == "Windows") {
  names(pd) <- vapply(names(pd), function(x) {
    ifelse(Encoding(x) != "unknown", iconv(x, "UTF-8", "latin1"), x)}, character(1))
}

# Get length of column headers for the table, and truncate manifest text if needed:
max_length <- 110 - 2*length(names(pd)) - sum(str_length(names(pd)[-2]))
max_length <- floor(max_length/5)*5

min_length <- str_length(cf$replacement[cf$original == "question"])
max_length <- if (max_length < min_length)  min_length else max_length

# Shorten the strings and insert them into the data
text <- pd[[cf$replacement[cf$original == "question"]]]
text <- ifelse(str_length(text) >= max_length, paste0(strtrim(text, width=max_length-3), "..."), text)
pd[[cf$replacement[cf$original == "question"]]] <- text

# Divide the data for the two tables
first_table <- filter(pd, latent %in% latents[1:3]) %>%
               select(-latent) %>%
               xtable(digits=1)

second_table <- filter(pd, latent %in% latents[4:length(latents)]) %>%
                select(-latent) %>%
                xtable(digits=1)

# Capture output and alter to color negative values in red.
first_table <- capture.output(print.xtable(first_table, size="\\tiny", comment=F, include.rownames=F))
second_table <- capture.output(print.xtable(second_table, size="\\tiny", comment=F, include.rownames=F))

first_table <- gsub("(\\s|^)(-\\d?\\d\\.\\d*)", "\\1\\\\textcolor[HTML]{D2232B}{\\2}", first_table)
second_table <-  gsub("(\\s|^)(-\\d?\\d\\.\\d*)", "\\1\\\\textcolor[HTML]{D2232B}{\\2}", second_table)


# Print the first table
cat(first_table, sep="\n")
```


```{r, eval=subentities}
# Frametitle
cat("##", "", "\n", sep=" ")

cat(second_table, sep="\n")
```

# Påstander

```{r, eval=statement_metric}
## USED FOR METRIC STATEMENTS

# Frametitle
cat("##", "","\n", sep="")

# Get all statement vars and look for the unique ones (TODO: prep. for more than one statement section)
mvar <- sub("^(q[0-9]{1,2}).?", "\\1", mm$manifest[mm$latent == "statement_metric"], ignore.case=TRUE) %>%
        na.omit() %>%
        unique()

# Get the manifests
manifests <- mm %>%
             select(manifest, text) %>%
             filter(grepl(paste0("^", mvar), manifest, ignore.case=TRUE)) %>%
             mutate(manifest = tolower(manifest))

# Gather the data for the table
pd <- df %>%
      select(mainentity, starts_with(mvar)) %>%
      filter(mainentity == entity) %>%
      group_by(mainentity) %>%
      mutate_each(funs(clean = gsub("([0-9]+).*$", "\\1", .)), -mainentity) %>%
      mutate_each(funs(rs = (as.numeric(.)-1)*(100/9)), -mainentity) %>%
      summarise_each(funs(m = mean(., na.rm=TRUE)), -mainentity)

# Add the contrast (average of the current or previous study)
if (contrast) {
  pd <- cd %>%
        select(starts_with(mvar), w) %>%
        mutate_each(funs(clean = gsub("([0-9]+).*$", "\\1", .)), -w) %>%
        mutate_each(funs(rs = (as.numeric(.)-1)*(100/9)), -w) %>%
        summarise_each(funs(m = weighted.mean(., w=w, na.rm=TRUE)), -w) %>%
        mutate(mainentity = ctr_sum) %>%
        bind_rows(pd, .)

} else {
  pd <- df %>%
        select(starts_with(mvar), w) %>%
        mutate_each(funs(clean = gsub("([0-9]+).*$", "\\1", .)), -w) %>%
        mutate_each(funs(rs = (as.numeric(.)-1)*(100/9)), -w) %>%
        summarise_each(funs(m = weighted.mean(., w=w, na.rm=TRUE)), -w) %>%
        mutate(mainentity = stu_sum) %>%
        bind_rows(pd, .)
}

# Convert to a longer format and convert to proper variable names.
pd %<>% gather(statement, score, -mainentity) %>%
        left_join(manifests, by=c("statement" = "manifest")) %>%
        mutate(text = str_wrap(text, 40))

y_max <- ifelse(max(pd$score) < 90, round(max(pd$score)+10, -1), 100)
y_min <- ifelse(min(pd$score) > 10, round(min(pd$score)-10, -1), 0)

# Create the plot
p <- ggplot(pd, aes(x=text, y=score, fill=mainentity, ymax=max(score)))
p + geom_bar(stat="identity", width=0.5, position=position_dodge(width=0.6)) + 
    scale_color_manual(values = setNames(palette, levels(pd$mainentity))) +
    scale_x_discrete(labels = function(x) str_wrap(x, width = 15)) +
    geom_text(aes(label=format(round(score, 1))), position=position_dodge(width=0.6),
              size=3, colour="#23373b", vjust=-1.1) + 
    scale_y_continuous(limits=c(y_min,y_max), oob = rescale_none) +
    guides(fill = guide_legend(keywidth = .5, keyheight = .5)) +
    plot_theme()

```

```{r, eval=statement_categorical}
## USED FOR CATEGORICAL STATEMENTS

# Frametitle
cat("##", "","\n", sep="")

mvar <- sub("^(q[0-9]{1,2}).?", "\\1", mm$manifest[mm$latent == "statement_categorical"], ignore.case=TRUE) %>%
        na.omit() %>%
        unique()

# Get the manifests
manifests <- mm %>%
             select(manifest, question) %>%
             filter(grepl(paste0("^", mvar), manifest, ignore.case=TRUE)) %>%
             mutate(manifest = tolower(manifest))

# Gather the data for the table
pd <- df %>%
      select(mainentity, starts_with(mvar)) %>%
      filter(mainentity == entity) %>%
      gather(statement, answer, -mainentity) %>%
      mutate(answer = factor(answer, 
              levels=unique(na.omit(answer)))) %>%
      count(mainentity, statement, answer) %>%
      filter(!is.na(answer)) %>%
      mutate(proportion = prop.table(n)) %>%
      select(-n) %>%
      spread(answer, proportion, fill = 0)

# Add the contrast (average of the current or previous study)
if (contrast) {
  pd <- cd %>%
        select(starts_with(mvar), w) %>%
        gather(statement, answer, -w) %>%
        mutate(answer = factor(answer, 
               levels=unique(na.omit(answer)))) %>%
        count(statement, answer, wt=w) %>%
        filter(!is.na(answer)) %>%
        mutate(proportion = prop.table(n)) %>%
        select(-n) %>%
        mutate(mainentity = ctr_sum) %>%
        spread(answer, proportion, fill = 0) %>%
        bind_rows(pd, .)

} else {
  pd <- df %>%
        select(starts_with(mvar), w) %>%
        gather(statement, answer, -w) %>%
        mutate(answer = factor(answer, 
                levels=unique(na.omit(answer)))) %>%
        count(statement, answer, wt=w) %>%
        filter(!is.na(answer)) %>%
        mutate(proportion = prop.table(n)) %>%
        select(-n) %>%
        mutate(mainentity = stu_sum) %>%
        spread(answer, proportion, fill = 0) %>%
        bind_rows(pd, .)
}

# Convert to a longer format and convert to proper variable names.
pd %<>% gather(answer, proportion, -mainentity, -statement) %>%
        left_join(manifests, by=c("statement" = "manifest")) %>%
        mutate(question = str_wrap(question, 40)) %>%
        mutate(mainentity = factor(as.character(mainentity), levels = c(entity, if (contrast) ctr_sum else stu_sum)))

# Create the plot
p <- ggplot(pd, aes(x=answer, y=proportion, fill=mainentity, group=mainentity, ymin=0, ymax=1))
p + geom_bar(stat="identity", width=0.5, position=position_dodge(width=0.6)) +
    scale_fill_manual(values=setNames(palette, levels(pd$mainentity)), drop=FALSE) +
    facet_wrap(~ question, ncol=3, scales="free_x") +
    scale_x_discrete(labels = function(x) str_wrap(x, width = 15)) + 
    scale_y_continuous(labels=percent) +
    geom_text(aes(label=paste0(round(proportion*100, digits=0), "%")),  
              size=2, colour="#23373b", position=position_dodge(width=0.6), vjust=-1.1, hjust=.35) +
    guides(fill = guide_legend(keywidth = .5, keyheight = .5)) +
    plot_theme() + 
    theme(panel.grid = element_blank(),
          panel.margin = unit(2, "lines"))
```

# Anbefalingsadferd

```{r}
# Frametitle
cat("##", mm$question[tolower(mm$latent) %in% "loyal" & grepl("15b$", tolower(mm$manifest))], "\n", sep=" ")

# Add the contrast (average of the current or previous study)
if (contrast) {
  pd <- df %>% filter(mainentity == entity) %>% bind_rows(., mutate(cd, mainentity = ctr_sum))
} else {
  pd <- df %>% filter(mainentity == entity) %>% bind_rows(., mutate(df, mainentity = stu_sum))
}

# Get the variable name
mvar <- mm$manifest[tolower(mm$latent) %in% "loyal" & grepl("15b$", tolower(mm$manifest))]

# Gather the data
pd <- pd %>%
      mutate(recom = pd[[tolower(mvar)]]) %>%
      select(mainentity, recom, w) %>%
      filter(!is.na(recom)) %>%
      mutate(w = as.numeric(w)) %>%
      mutate(recom = clean_score(recom)) %>%
      mutate(recom = ifelse(recom %in% 1:5L, "Negativ", ifelse(recom %in% 8:10L, "Positiv", "Nøytral"))) %>%
      count(mainentity, recom, wt = w) %>%
      mutate(proportion = prop.table(n)) %>%
      select(-n)

# Convert to proper format for plotting
pd <- pd %>%
      spread(recom, proportion, fill = 0) %>%
      gather(recom, proportion, -mainentity) %>%
      mutate(mainentity = factor(as.character(mainentity), levels = c(entity, if (contrast) ctr_sum else stu_sum)))

# Create the plot
p <- ggplot(pd, aes(x=recom, y=proportion, fill=mainentity, group=mainentity, ymin=0, ymax=1))
p + geom_bar(stat="identity", width=0.5, position=position_dodge(width=0.6)) +
    scale_x_discrete(labels = function(x) str_wrap(as.character(x), width = 15)) + 
    scale_y_continuous(labels=percent) +
    geom_text(aes(label=paste0(round(proportion*100, digits=0), "%")),  
              size=3, colour="#23373b", position=position_dodge(width=0.6), vjust=-1.1, hjust=.35) +
    guides(fill = guide_legend(keywidth = .5, keyheight = .5)) +
    plot_theme() + 
    theme(title = element_text(hjust = -.1))

```


# Andel klager

```{r}
# Frametitle
cat("##", mm$question[mm$latent %in% "complaint"][1], "\n", sep=" ")

# Add the contrast (average of the current or previous study)
if (contrast) {
  pd <- df %>% filter(mainentity == entity) %>% bind_rows(., mutate(cd, mainentity = ctr_sum))
} else {
  pd <- df %>% filter(mainentity == entity) %>% bind_rows(., mutate(df, mainentity = stu_sum))
}

# Get the variable name
mvar <- mm$manifest[mm$latent %in% "complaint"]
mvar_values <- unlist(str_split(mm$values[mm$manifest %in% mvar], "\n"))

# Gather the data for the table
pd <- pd %>%
      mutate(complaint = pd[[tolower(mvar)]]) %>%
      select(mainentity, complaint) %>%
      filter(!is.na(complaint)) %>%
      mutate(complaint = factor(complaint, levels = mvar_values, ordered = TRUE)) %>%
      count(mainentity, complaint) %>%
      mutate(proportion = prop.table(n)) %>%
      select(-n)

# Convert to proper format for plotting
pd <- pd %>%
      spread(complaint, proportion, fill = 0, drop = FALSE) %>%
      gather(complaint, proportion, -mainentity) %>%
      mutate(mainentity = factor(as.character(mainentity), levels = c(entity, if (contrast) ctr_sum else stu_sum)))

# Create the plot
p <- ggplot(pd, aes(x=complaint, y=proportion, fill=mainentity, group=mainentity, ymin=0, ymax=1))
p + geom_bar(stat="identity", width=0.5, position=position_dodge(width=0.6)) +
    scale_x_discrete(labels = function(x) str_wrap(as.character(x), width = 15)) + 
    scale_y_continuous(labels=percent) +
    geom_text(aes(label=paste0(round(proportion*100, digits=0), "%")),  
              size=3, colour="#23373b", position=position_dodge(width=0.6), vjust=-1.1, hjust=.35) +
    guides(fill = guide_legend(keywidth = .5, keyheight = .5)) +
    plot_theme() + 
    theme(title = element_text(hjust = -.1))

# Workbook (create and add open answers etc if needed)
wb <- createWorkbook()
```

# Klager

```{r, eval=complaint}
# Frametitle
frametitle <- paste("##", "Hva dreide klagen seg om?", "(uredigerte svar)")

# Variable
mvar <- mm$manifest[mm$latent %in% c("open_complaint", "open_wouldcomplain")]

pd <- df %>%
      select(mainentity, one_of(tolower(mvar))) %>%
      gather(var, complaint, -mainentity) %>%
      filter(mainentity == entity & !is.na(complaint)) %>%
      mutate(complaint = gsub("^[!#$%()*,.:;<=>@^_`|~.{}-]|[\\\\]*", "", complaint)) %>%
      mutate(complaint = paste("-", complaint)) %>%
      mutate(nchars = str_length(complaint), nlines = ceiling(nchars/135), tlines = cumsum(nlines)) %>%
      mutate(page = ifelse(tlines <= 25, 1, ifelse(tlines <= 50 & tlines > 25, 2, 3)))

# Inform if no complaints were found
if (nrow(pd) == 0) {
  
  cat(frametitle, "Ingen årsaker oppgitt av respondentene.", sep="\n")

  # Write to sheet if text is too long (>3 pages)
  } else if (max(pd$tlines) > 75) {
  
  cat(frametitle, "Se vedlagt regneark i Excel format.", sep="\n")
  pd %>% mutate(complaint = gsub("^- ", "", complaint)) %>%
         select("Klager" = complaint) %>%
         to_sheet(wb, title = frametitle, sheet = "Klaget")
  
  # Print the results
  } else {

  for (i in unique(pd$page)) { cat(frametitle, pd$complaint[pd$page == i], "\n", sep="\n") }
  
  }

# Make sure changes to WB are registered
wb <- wb
```

# Åpne svar

```{r, eval=open_answer}
# Frametitle
frametitle <- paste("##", mm$question[mm$latent %in% "open_answer"][1], "(uredigerte svar)")

# Variable
mvar <- mm$manifest[mm$latent %in% "open_answer"]

pd <- df %>%
      select(mainentity, one_of(tolower(mvar))) %>%
      gather(var, complaint, -mainentity) %>%
      filter(mainentity == entity & !is.na(complaint)) %>%
      mutate(complaint = gsub("^[!#$%()*,.:;<=>@^_`|~.{}-]|[\\\\]*", "", complaint)) %>%
      mutate(complaint = paste("-", complaint)) %>%
      mutate(nchars = str_length(complaint), nlines = ceiling(nchars/135), tlines = cumsum(nlines)) %>%
      mutate(page = ifelse(tlines <= 25, 1, ifelse(tlines <= 50 & tlines > 25, 2, 3)))

# Inform if no complaints were found
if (nrow(pd) == 0) {
  
  cat(frametitle, "Ingen årsaker oppgitt av respondentene.", sep="\n")

  # Write to sheet if text is too long (>3 pages)
  } else if (max(pd$tlines) > 75) {
  
  cat(frametitle, "Se vedlagt regneark i Excel format.", sep="\n")
  pd %>% mutate(complaint = gsub("^- ", "", complaint)) %>%
         select("Klager" = complaint) %>%
         to_sheet(wb, title = frametitle, sheet = "Åpne svar")
  
  # Print the results
  } else {

  for (i in unique(pd$page)) { cat(frametitle, pd$complaint[pd$page == i], "\n", sep="\n") }
  
  }

# Make sure changes to WB are registered
wb <- wb
```

```{r, eval=oa_positive}
# Frametitle
frametitle <- paste("##", mm$question[mm$latent %in% "oa_positive"][1], "(uredigerte svar)")

# Variable
mvar <- mm$manifest[mm$latent %in% "oa_positive"]

pd <- df %>%
      select(mainentity, one_of(tolower(mvar))) %>%
      gather(var, complaint, -mainentity) %>%
      filter(mainentity == entity & !is.na(complaint)) %>%
      mutate(complaint = gsub("^[!#$%()*,.:;<=>@^_`|~.{}-]|[\\\\]*", "", complaint)) %>%
      mutate(complaint = paste("-", complaint)) %>%
      mutate(nchars = str_length(complaint), nlines = ceiling(nchars/135), tlines = cumsum(nlines)) %>%
      mutate(page = ifelse(tlines <= 25, 1, ifelse(tlines <= 50 & tlines > 25, 2, 3)))

# Inform if no complaints were found
if (nrow(pd) == 0) {
  
  cat(frametitle, "Ingen årsaker oppgitt av respondentene.", sep="\n")

  # Write to sheet if text is too long (>3 pages)
  } else if (max(pd$tlines) > 75) {
  
  cat(frametitle, "Se vedlagt regneark i Excel format.", sep="\n")
  pd %>% mutate(complaint = gsub("^- ", "", complaint)) %>%
         select("Klager" = complaint) %>%
         to_sheet(wb, title = frametitle, sheet = "Positivt")
  
  # Print the results
  } else {

  for (i in unique(pd$page)) { cat(frametitle, pd$complaint[pd$page == i], "\n", sep="\n") }
  
  }

# Make sure changes to WB are registered
wb <- wb
```

```{r, eval=oa_negative}
# Frametitle
frametitle <- paste("##", mm$question[mm$latent == "oa_negative" & !is.na(mm$latent)][1], "(uredigerte svar)")

# Variable
mvar <- mm$manifest[mm$latent %in% "oa_negative"]

pd <- df %>%
      select(mainentity, one_of(tolower(mvar))) %>%
      gather(var, complaint, -mainentity) %>%
      filter(mainentity == entity & !is.na(complaint)) %>%
      mutate(complaint = gsub("^[!#$%()*,.:;<=>@^_`|~.{}-]|[\\\\]*", "", complaint)) %>%
      mutate(complaint = paste("-", complaint)) %>%
      mutate(nchars = str_length(complaint), nlines = ceiling(nchars/135), tlines = cumsum(nlines)) %>%
      mutate(page = ifelse(tlines <= 25, 1, ifelse(tlines <= 50 & tlines > 25, 2, 3)))

# Inform if no complaints were found
if (nrow(pd) == 0) {
  
  cat(frametitle, "Ingen årsaker oppgitt av respondentene.", sep="\n")

  # Write to sheet if text is too long (>3 pages)
  } else if (max(pd$tlines) > 75) {
  
  cat(frametitle, "Se vedlagt regneark i Excel format.", sep="\n")
  pd %>% mutate(complaint = gsub("^- ", "", complaint)) %>%
         select("Klager" = complaint) %>%
         to_sheet(wb, title = frametitle, sheet = "Forbedring")
  
  # Print the results
  } else {

  for (i in unique(pd$page)) { cat(frametitle, pd$complaint[pd$page == i], "\n", sep="\n") }
  
  }

# Make sure changes to WB are registered
wb <- wb
```

```{r, results='hide'}
# Write the wb if necessary
if (length(sheets(wb))) {
  saveWorkbook(wb, paste0("../Reports/", entity, " - åpne svar.xlsx"), overwrite = TRUE)
}
```

